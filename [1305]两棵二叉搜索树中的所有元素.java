/**
<p>ç»™ä½ &nbsp;<code>root1</code> å’Œ <code>root2</code>&nbsp;è¿™ä¸¤æ£µäºŒå‰æœç´¢æ ‘ã€‚è¯·ä½ è¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«&nbsp;<strong>ä¸¤æ£µæ ‘&nbsp;</strong>ä¸­çš„æ‰€æœ‰æ•´æ•°å¹¶æŒ‰ <strong>å‡åº</strong> æ’åºã€‚.</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e1.png" /></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>root1 = [2,1,4], root2 = [1,0,3]
<strong>è¾“å‡ºï¼š</strong>[0,1,1,2,3,4]
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e5-.png" /></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>root1 = [1,null,8], root2 = [8,1]
<strong>è¾“å‡ºï¼š</strong>[1,1,8,8]
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
	<li>æ¯æ£µæ ‘çš„èŠ‚ç‚¹æ•°åœ¨&nbsp;<code>[0, 5000]</code> èŒƒå›´å†…</li>
	<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
<div><div>Related Topics</div><div><li>æ ‘</li><li>æ·±åº¦ä¼˜å…ˆæœç´¢</li><li>äºŒå‰æœç´¢æ ‘</li><li>äºŒå‰æ ‘</li><li>æ’åº</li></div></div><br><div><li>ğŸ‘ 118</li><li>ğŸ‘ 0</li></div>
*/

//leetcode submit region begin(Prohibit modification and deletion)

import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        List<Integer> nums1 = new ArrayList<>();
        List<Integer> nums2 = new ArrayList<>();
        inorder(root1, nums1);
        inorder(root2, nums2);

        List<Integer> merged = new ArrayList<>();
        int p1 = 0, p2 = 0;
        while (true) {
            if (p1 == nums1.size()) {
                merged.addAll(nums2.subList(p2, nums2.size()));
                break;
            }
            if (p2 == nums2.size()) {
                merged.addAll(nums1.subList(p1, nums1.size()));
                break;
            }
            if (nums1.get(p1) < nums2.get(p2)) {
                merged.add(nums1.get(p1++));
            } else {
                merged.add(nums2.get(p2++));
            }
        }
        return merged;
    }

    public void inorder(TreeNode node, List<Integer> res) {
        if (node != null) {
            inorder(node.left, res);
            res.add(node.val);
            inorder(node.right, res);
        }
    }
}
//leetcode submit region end(Prohibit modification and deletion)
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}